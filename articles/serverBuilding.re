= AWSでサーバを立てよう

この章では実際にAWSのEC2を使ってサーバを立てます。

インフラエンジニアのお仕事体験みたいできっと楽しいですよ！

//pagebreak

== 事前準備

=== お使いのパソコンがWindowsの場合

Windowsのパソコンを使っている方は、サーバを立てる前に「ターミナル」と呼ばれる黒い画面のソフトをインストール@<fn>{wsl}しておきましょう。サーバに接続するときにはこのターミナルを使うのですが、ターミナルのソフトには色々な種類があります。

 * RLogin（@<href>{http://nanno.dip.jp/softlib/man/rlogin/}）
 * Poderosa（@<href>{https://ja.poderosa-terminal.com/}）
 * Tera Term（@<href>{https://ja.osdn.net/projects/ttssh2/}）

//footnote[wsl][既にWSL（Windows Subsystem for Linux）やWSL2が使える環境であれば、次の項「お使いのパソコンがMacの場合」の手順を参考に、ターミナルをインストールする代わりにWSLを使っても構いません。]

//image[rlogin][RLogin][scale=0.8]{
//}

本書ではいちばん上のRLogin（@<img>{rlogin}）を使って説明していきますので、特にこだわりがなければRLoginを使うことをお勧めします。RLoginの「実行プログラム(64bit)@<fn>{64bit}」（@<img>{downloadRLogin01}）のURL、@<href>{http://nanno.dip.jp/softlib/program/rlogin_x64.zip}をクリックしてください。

//footnote[64bit][もしお使いのパソコンでWindowsが32bit版だった場合は「実行プログラム(32bit)」のURLをクリックしてください。]

//image[downloadRLogin01][「実行プログラム(64bit)」のURLをクリックしてダウンロード][scale=0.8]{
//}

ダウンロードしたZIPファイルを保存（@<img>{downloadRLogin02}）します。保存場所はどこでも構いませんが、後でどこに置いたか分からなくなりそうな人はデスクトップに保存しておきましょう。

//image[downloadRLogin02][「ファイルを保存する」でパソコンに保存][scale=0.8]{
//}

デスクトップのZIPファイル（rlogin_x64.zip）を右クリック（@<img>{downloadRLogin03}）して、解凍＞デスクトップに解凍@<fn>{lhaplus}をクリックします。

//image[downloadRLogin03][ZIPファイルを右クリックして解凍＞デスクトップに解凍][scale=0.8]{
//}

//footnote[lhaplus][ZIPファイルを右クリックしても「解凍」が見当たらないときは、圧縮・解凍の定番ソフトであるLhaplusをインストールしましょう。 @<href>{https://forest.watch.impress.co.jp/library/software/lhaplus/}]

解凍したら、デスクトップにできた「rlogin_x64」というフォルダの中にある「RLogin.exe」@<fn>{filenameExtension}（@<img>{downloadRLogin04}）をダブルクリックすればRLoginが起動（@<img>{downloadRLogin05}）します。

//footnote[filenameExtension][フォルダの中にRLoginはあるけどRLogin.exeなんて見当たらない…という場合、ファイルの拡張子が非表示になっています。この後も拡張子を含めてファイル名を確認する場面が何度かでてきますので、表示されていない人は「拡張子 表示」でGoogle検索して、拡張子が表示されるようにWindowsの設定を変更しておきましょう。]

//image[downloadRLogin04][RLogin.exeをダブルクリック][scale=0.6]{
//}

//image[downloadRLogin05][RLoginが起動した][scale=0.8]{
//}

これでRLoginのインストールは完了です。起動したRLoginはいったん「キャンセル」をクリックして閉じてしまって構いません。また後で使いますので、デスクトップの「rlogin_x64」フォルダとその中にある「RLogin.exe」をごみ箱へ捨てないように注意してください。

=== お使いのパソコンがMacの場合

Macを使っている方は、最初から「ターミナル」（@<img>{mac02}）というソフトがインストールされていますのでそちらを利用しましょう。

//image[mac02][最初からインストールされている「ターミナル」を使おう][scale=0.8]{
//}

ターミナルがどこにあるのか分からないときは、Macの画面で右上にある虫眼鏡のマークをクリックして、Spotlightで「ターミナル」と検索（@<img>{mac01}）すれば起動できます。

//image[mac01][どこにあるのか分からなかったらSpotlightで「ターミナル」と検索][scale=0.8]{
//}

以上で事前準備は完了です。お待たせしました。いよいよサーバを立てましょう。

== EC2でサーバを立てる

AWSにはRoute53のようなネームサーバをはじめとして色々なサービスがありますが、サーバはAmazon Elastic Compute Cloudの略で「EC2」（イーシーツー）と呼ばれています。ちなみにAWSではサーバのことを、@<ttb>{インスタンス}と呼びます。ここから先でインスタンスと書いてあったら「ああ、サーバのことね」と思ってください。

それではマネジメントコンソールの左上にある「サービス」から、「コンピューティング」の下にある「EC2」（@<img>{selectEC2}）をクリックしてください。

//image[selectEC2][サービス＞コンピューティング＞EC2][scale=0.8]{
//}

「EC2」をクリックすると、EC2のダッシュボード（@<img>{EC2Dashboard}）が表示されます。少し下にスクロールして「注意: インスタンスは アジアパシフィック (東京) リージョンで起動されます」と書いてあることを確認したら、「インスタンスを起動」をクリックしてください。

//image[EC2Dashboard][EC2ダッシュボードで「インスタンスを起動」をクリック][scale=0.8]{
//}

プルダウンが表示されるので、再び「インスタンスを起動」をクリック（@<img>{EC2Dashboard2}）します。

//image[EC2Dashboard2][再び「インスタンスを起動」をクリック][scale=0.8]{
//}

ここから7つのステップでインスタンスを作成していきます。

=== ステップ 1: Amazon マシンイメージ (AMI)

はじめにAmazonマシンイメージ、略してAMIを選択します。AMIはこれから作る@<ttb>{サーバのもととなるテンプレート}のようなものです。

左側の「無料利用枠のみ」にチェックを入れる（@<img>{ec2Step01}）と、無料利用枠以外のAMIは選択できなくなります。うっかりWindows Serverのような有料AMIを選択しないようにチェックを入れておきましょう。

//image[ec2Step01][「無料利用枠のみ」にチェックを入れて「Amazon Linux 2 AMI」を選択][scale=0.8]{
//}

パソコンにはOSという基本ソフトが入っていて、WordやExcel、ChromeといったソフトはそのOSの上で動いています。皆さんのパソコンにも「Windows 10」や「macOS Catalina」などのOSが入っていますよね。

そしてパソコンと同じように、サーバにも「Linux」や「Windows Server」といったサーバ用のOSがあります。サーバを立てるときにはLinuxを選択することが多いのですが、このLinuxの中にもさらに「RHEL（Red Hat Enterprise Linux）」や「CentOS」、「Ubuntu」などいろいろなディストリビューション（種類）があります。

今回はいちばん上にある「Amazon Linux 2」のAMIを選択します。Amazon Linux 2ならAWSのツールがあらかじめ入っており、AmazonによるOSのサポートも受けられる@<fn>{osSupport}ため、@<ttb>{AWSでサーバを立てるときはOSはAmazon Linux 2にする}ことをお勧めします。Amazon Linux 2はRed Hat系のディストリビューションですので、RHELやCentOSのサーバを使ったことがある方なら違和感なく使えると思います。

//footnote[osSupport][AmazonによるOSのサポートというのは「手取り足取り教えてくれる」ということではなく、たとえば「バグや脆弱性が発見されたときに修正バージョンを出してくれる」というものです。ちなみにAmazon Linux 2のサポート期限は2023年6月30日まで、と公式に発表されています。 @<href>{https://aws.amazon.com/jp/amazon-linux-2/faqs/}]

Amazon Linux 2はRHEL7系なのでCentOS 7と使い勝手はほぼ同じです。本書ではAmazon Linux 2を使用します。アーキテクチャは「64ビット(x86)」@<fn>{arm}のままにしておきます。@<fn>{apache}

//footnote[arm][もう1つの「64ビット(Arm)」を選択すると、T4gインスタンスのようにコストパフォーマンスに優れたGraviton2ベースのインスタンスタイプを使うことができます。しかし2020年12月時点で、t4g.microの無料利用枠は「2020年12月31日までの期間限定」とされており、またx86との互換性もないので、ここでは「64ビット(x86)」を選択します。 @<href>{https://aws.amazon.com/jp/ec2/faqs/#t4g-instances}]
//footnote[apache][ちなみにこの後インストールするApacheというミドルウェアは、Amazon Linux 2だとデフォルトが2.4系になります。]

=== ステップ 2: インスタンスタイプの選択

ステップ2ではインスタンスタイプを選択（@<img>{ec2Step02}）します。小～中規模のウェブサービスならT2インスタンス、データベースやキャッシュを処理させるならM5インスタンス、というように用途別にたくさん用意されているので、その中から適したスペックのインスタンスタイプを選びます。

//image[ec2Step02][t2.microを選択して「次のステップ: インスタンスの詳細の設定」をクリック][scale=0.8]{
//}

インスタンスタイプの接頭辞になっている「T2」や「M5」はインスタンスファミリーと呼ばれるグループを表しており、Tが汎用、Mはもう少し性能の高い汎用、CはCPU重視、Rはメモリ重視、のように特徴ごとに分かれています。文字の後ろの2や4といった数字は世代を表しているので、T2なら汎用向けのグループで2世代目ということですね。Tは3世代目となるT3もリリースされているので、2020年12月時点ではT2とT3がどちらも選択できる状態になっています。

インスタンスファミリーの後ろにあるnano、micro、small、medium、large、xlargeなどはCPUやメモリといったスペックの大きさを表します。t2.smallならCPU@<fn>{vCPU}が1コアでメモリが2GiB、t2.mediumならCPUは2コアでメモリが4GiBというように、大きくなるにつれて段々CPUやメモリが増えていきます。@<fn>{potato}

//footnote[vCPU][インスタンスタイプの表ではCPUが「vCPU」と書かれていると思います。仮想サーバ内にある仮想のCPUのことをVirtual CPU、略してvCPUといいます。]
//footnote[potato][small、medium、largeと段々中身が増えていくなんてマクドナルドのポテトと同じですね。]

今回は個人で「ちょっとWordPressのサイトを作ってみよう！」という用途なので高スペックは必要ありません。無料利用枠の対象となっているt2.microを選択して「次のステップ: インスタンスの詳細の設定」をクリックします。

===[column] 【コラム】T2系バーストモードの落とし穴

T2系のインスタンスタイプには落とし穴があるので注意が必要です。

たとえば先ほど選択したt2.microというインスタンスタイプはvCPUが1コアと書いてありますが、実際はベースラインという「普段はここまで使っていいよ」というラインがあり、サイトにあまりアクセスが来ておらずサーバがヒマなとき、vCPUの使用率がこのベースラインを下回っていれば「CPUクレジット」というものがちゃりんちゃりんと貯まっていきます。@<fn>{baseLine}CPUクレジットはt2.microなら1時間あたり6ずつ溜まっていって最大で144まで蓄積できます。

前述のベースラインはt2.microだとなんとたったの10%なので、普段はvCPUを1コアの1/10しか使えないということです。そしてサイトにアクセスがわーっと殺到してCPU使用率がベースラインの10%を超えるとバーストモードになり、バーストモードの間だけはvCPUが100%使えるようになります。

バーストモードの間は今まで貯めておいたCPUクレジットを使います。1クレジットにつき1分間バーストできるので、t2.microなら最大で144分しかバーストできません。つまりCPU使用率が10%を超える状態が2時間半続いたら、その時点でバーストが終了して強制的にまたvCPUが10%までしか使えなくなってしまうのです。

アクセスが殺到していたからvCPUを10%以上使っていたわけで、それが急に10%までしか使えなくなってしまったらどうなるのでしょう？バーストが終了した瞬間にサーバは過負荷となり、場合によってはサイトが応答できなくなってしまいます。

つまり今までオンプレミスでCPUが1コアのサーバを使っていてそれがちょうどよかったからといって、AWSでt2.microを選ぶと、実際はベースラインが10%なのでvCPUは実質0.1しかないため、AWSに引越しした途端サイトが落ちまくって「同じスペックを選んだはずなのにどうして？！」という事態になる可能性があるということです。

CPUクレジットが尽きたら追加課金でバーストモードを延長できるT2 Unlimitedというオプションもありますが、Unlimitedで延々課金されるくらいならもう少し上のインスタンスタイプを選んでベースラインを超えないようにしましょう。ちなみに3世代目のT3系はこのUnlimitedがデフォルトで有効になっているので「なーんだ、t3.microでも結構アクセスさばけるじゃん！」と思っていると、実はUnlimitedで延々課金されていた！となる初心者殺しな仕様といえます。

===[/column]

//footnote[baseLine][@<href>{https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/burstable-credits-baseline-concepts.html}]

=== ステップ 3: インスタンスの詳細の設定

ステップ3のインスタンスの詳細（@<img>{ec2Step03}）は、すべてデフォルト設定のままで構いません。そのまま「次のステップ: ストレージの追加」をクリックしてください。

//image[ec2Step03][何も変更せず「次のステップ: ストレージの追加」をクリック][scale=0.8]{
//}

=== ステップ 4: ストレージの追加

ステップ4ではサーバにくっつけるストレージの容量を設定（@<img>{ec2Step04}）します。ストレージというのはデータを保存しておく場所のことです。皆さんのパソコンにも「ハードディスク」というストレージがついていて、作ったファイルはそこに保存していますよね。

AmazonにはEBS@<fn>{ebs}というストレージサービスがあり、ここでは「EC2のサーバにくっつけるEBSボリュームの種類やサイズはどうしますか？」と聞かれています。

//image[ec2Step04][何も変更せず「次のステップ: タグの追加」をクリック][scale=0.8]{
//}

//footnote[ebs][EBSはAmazon Elastic Block Storeの略で、EC2向けのストレージサービスのことです。]

下部に「無料利用枠の対象であるお客様は30GBまでのEBS汎用(SSD)ストレージまたはマグネティックストレージを取得できます。」と書いてあるとおり、無料利用枠ではEBSを最大30GBまで使えますが、デフォルトの8GBのままで十分なので変更は不要です。「次のステップ: タグの追加」をクリックしてください。

=== ステップ 5: タグの追加

ステップ5ではインスタンスにタグを付けて分類（@<img>{ec2Step05}）できます。タグにはキーと値があり、たとえばキーが「environment（環境）」のタグを作って、インスタンスによって値を「production（本番）」や「staging（ステージング）」や「develop（開発）」にすることで、どれが本番のサーバでどれがステージングのサーバなのか区別できるようになります。

//image[ec2Step05][タグは作成せず「次のステップ: セキュリティグループの設定」をクリック][scale=0.8]{
//}

今回はサーバは1台しか立てないので、タグはつけずに先へ進みましょう。「次のステップ: セキュリティグループの設定」をクリックしてください。

=== ステップ 6: セキュリティグループの設定

ステップ6ではセキュリティグループの設定（@<img>{ec2Step06}）を行います。セキュリティグループというのはいわゆる「ファイアウォール」のことで、「自宅からのアクセスは通すけどそれ以外からは通さない」のように特定の通信のみを通してそれ以外は阻止することで、文字通り防火壁となってサーバを守ってくれます。

//image[ec2Step06][セキュリティグループ名と説明を変更したら「確認と作成」をクリック][scale=0.8]{
//}

上部の「セキュリティグループの割り当て」が「新しいセキュリティグループを作成する」になっていることを確認したら、次の2つを入力@<fn>{onlyEnglish}してください。（@<table>{securityGroup}）

//footnote[onlyEnglish][セキュリティグループ名や説明には日本語は使えませんので注意してください。]

//table[securityGroup][セキュリティグループの設定]{
セキュリティグループ名	ec2-security-group
説明	Allow from anywhere
//}

続いて「ここからのアクセスのみを通す」というルールを確認します。下部に「送信元が0.0.0.0/0のルールを指定すると、すべてのIPアドレスからインスタンスにアクセスすることが許可されます。」という警告が出ているとおり、デフォルトのルールは「SSH@<fn>{ssh}での接続はどこからでも通す」という設定になっています。@<fn>{allowFrom}このままで構いませんので「確認と作成」をクリックしてください。

//footnote[ssh][SSHという単語が突然出てきましたが、SSHについては後述します。]
//footnote[allowFrom][サーバにどこからでも接続できてしまうのはよくないので、できればSSHでのアクセス元も制限したいのですが、ここで制限をかけるとたとえば「出先でモバイルWi-Fiに繋いだとき」などに接続元のIPアドレスが変わってファイアウォールで阻止され、あなた自身もサーバに接続できなくなってしまいます。今自宅にいて今後も自宅からしかサーバにSSHで接続しない！自宅のIPアドレスは固定だから絶対に変わらない！という人だけ、ルールのソースを「マイIP」にして説明に「IP address of my house」と書いておいてください。こうするとあなたの自宅のIPアドレスからしかSSHで接続できなくなります。]

=== ステップ 7: インスタンス作成の確認

ステップ7は「この内容でインスタンスを作成しますよ？問題ないですか？」という確認の画面（@<img>{ec2Step07}）です。表示されている内容で問題なければ「起動」をクリックしてください。

//image[ec2Step07][問題なければ「起動」をクリック][scale=0.8]{
//}

=== キーペアのダウンロード

「起動」をクリックすると「既存のキーペアを選択するか、新しいキーペアを作成します。」と表示（@<img>{ec2Step08}）されます。「新しいキーペアの作成」を選んでキーペア名を「start-aws-keypair」にしてください。

//image[ec2Step08][キーペア名を「start-aws-keypair」にして「キーペアのダウンロード」をクリック][scale=0.8]{
//}

キーペアとはサーバに入るための鍵と鍵穴のペアのことです。サーバのドアに鍵穴を設置して、あなたのパソコンに鍵を保存することで、鍵を持っているあなたしかサーバに入れなくなります。キーペア名を入力したら「キーペアのダウンロード」をクリック（@<img>{ec2Step09}）してください。そしてダウンロードしたキーペア（start-aws-keypair.pem）はパソコンの@<ttb>{デスクトップなど絶対に忘れない場所に保存}（@<img>{mac03}、@<img>{ec2Step10}）しておいてください。

//image[ec2Step09][ダウンロードしたキーペア（start-aws-keypair.pem）を保存][scale=0.6]{
//}

//image[mac03][Macの人はデスクトップなど絶対に忘れない場所に保存しておくこと][scale=0.6]{
//}

//image[ec2Step10][Windowsの人もデスクトップなど絶対に忘れない場所に保存しておくこと][scale=0.6]{
//}

このキーペア（start-aws-keypair.pem）はこれ以降@<ttb>{二度とダウンロードできません}。家の鍵と同じで、キーペアをなくしてしまうとこの後サーバに入ろうとしたときに「鍵がない！入れない！」となります。@<ttb>{絶対になくさないでください}。

キーペアをパソコンに保存したら「インスタンスの作成」をクリック（@<img>{ec2Step11}）してください。

//image[ec2Step11][キーペアをパソコンに保存したら「インスタンスの作成」をクリック][scale=0.8]{
//}

「インスタンスの作成」をクリックすると、作成ステータスの画面で「インスタンスは現在作成中です」（@<img>{createStatus}）と表示されます。

//image[createStatus][「インスタンスは現在作成中です」と表示されたらインスタンスIDをクリック][scale=0.8]{
//}

「i-0b96448d17e7dadee」のようなインスタンスIDをクリックして、EC2ダッシュボードに戻りましょう。

=== 作成したインスタンスに名前をつける

作成したインスタンスが表示（@<img>{instanceList}）されていますので、このインスタンスに名前を付けておきましょう。Nameのところにカーソルを持っていくと、鉛筆のようなマークが表示されますのでクリックしてください。

//image[instanceList][Nameのところにある鉛筆のようなマークをクリック][scale=0.8]{
//}

Nameに「start-aws-instance」と書いたら「保存」を押して（@<img>{instanceName}）ください。インスタンス名には日本語を使わないことをお勧めします。

//image[instanceName][Nameに「start-aws-instance」と書いたら「保存」を押す][scale=0.8]{
//}

次の2つを確認（@<img>{namedInstance}）したら、インスタンスの作成は完了です。@<fn>{notYet}

//footnote[notYet][もしインスタンスの状態が「実行中」以外だった場合は、少し待ってから更新マークをクリックしてみてください。]

 * Nameが「start-aws-instance」になっていること
 * インスタンスの状態が「実行中」になっていること

おめでとうございます！あなたは無事に「サーバを立てた」のです！それでは自分で立てたサーバに入ってみましょう。

//image[namedInstance][インスタンスの作成完了][scale=0.8]{
//}

=== 【ドリル】秘密鍵をなくしたらどうなる？

==== 問題

ある日パソコンが壊れてしまい、パソコン上に保存してあったキーペアこと「start-aws-keypair.pem」も消滅してしまいました。キーペアはサーバへSSHでログインするときに必要なのですが、キーペアがなくなってしまったのであなたはとても困っています。どうしたらまたサーバにログインできるようになるのでしょうか？

 * A. キーペアをマネジメントコンソールのEC2ダッシュボードから再ダウンロードすればよい
 * B. キーペアをなくしたらそのサーバには二度とログインできない
 * C. マネジメントコンソールで新しいキーペアを作成して、そのサーバに適用すればよい

//raw[|latex|\begin{reviewimage}\begin{flushright}\includegraphics[width=0.5\maxwidth\]{./images/answerColumnShort.png}\end{flushright}\end{reviewimage}]

==== 解答

正解はCです。キーペアは1回きりのダウンロードで再発行もできません。壊れたパソコンからキーペアを持ち出せない場合、マネジメントコンソールで新しいキーペアを作成した上で、インスタンスの「ユーザーデータ」を編集して、さらにインスタンスを一度停止して再起動させることで、インスタンスでその新しいキーペアが使えるようにしなければなりません。@<fn>{howtoRemakeKeypair}

新しくインスタンスを作り直すしか方法がなかった頃に比べればまだマシですが、それでもこの方法はかなり面倒ですし、サーバも一度停止させなければいけません。キーペアは絶対に無くさないようにしてください。

//footnote[howtoRemakeKeypair][詳しくは「最初の起動後にSSHキーペアを紛失した場合、Amazon EC2インスタンスに接続するにはどうすればよいですか?」を参照してください。 @<href>{https://aws.amazon.com/jp/premiumsupport/knowledge-center/user-data-replace-key-pair-ec2/}]

===[column] 【コラム】サーバは「立てる」もの？「建てる」もの？

サーバは「立てる」ものでしょうか？それとも「建てる」ものでしょうか？

英語だとサーバ構築を「server build」と表現しますし「築く」「建築する」という意味では「建てる」が正しい気もします。

一方、パソコンが起動することをよく「立ち上がる」と言いますし、色々な設定をしてやった我が子のようなサーバがようやく「立った」という意味では、「立てる」でいいような気もします。

個人的には、儀同世津子がパソコンのスイッチをつけて「立ち上がろうとしてるところ」と言ったら、瀬戸千衣は「立ち上がるの？」と眉を寄せた@<fn>{whoInside}ので筆者は「立てる」派です。

===[/column]

//footnote[whoInside][森博嗣の「封印再度」（講談社文庫）549ページより引用。]

== サーバに「入る」とは？

無事にEC2でインスタンスが作成できたので、いよいよサーバに入ってみたいと思いますが…ところでサーバに「入る」といわれてピンときますか？サーバに「入る」って、いったいどういうことでしょう？

次の2つはどちらもサーバに「入る」という行為です。

 * ファイルをアップするためにWinSCPやCyberduckでサーバに「接続する」
 * ログを見るためにターミナルでサーバに「ログインする」

「今までサーバになんか入ったことない！」という方でも、こんな画面（@<img>{winScp}）を見たことはありませんか？

//image[winScp][WinSCPでサーバに「入る」][scale=0.8]{
//}

これは「SCPクライアント」という種類のソフトで、サーバへ画像やHTMLファイルなどをアップロードするときによく使われます。左側が自分が使っているパソコンで、右側がサーバに「入って」います。

もう1つ、こんな画面（@<img>{terminal}）も見たことはありませんか？

//image[terminal][ターミナルでサーバに「入る」][scale=0.8]{
//}

こちらは「ターミナル」という種類のソフトで、サーバでログの確認をしたり設定ファイルを書き換えたりするときに使われます。エンジニア以外の方には、いわゆる「黒い画面」と言った方がお馴染みかもしれません。

ところでSCPクライアントの右側とターミナルを見比べてみてください。どちらも「image」というフォルダがあって、「aaa.html」と「bbb.php」というファイルがありますよね。実はこの2つ、どちらも同じサーバに入って同じフォルダを見ています。実際の画面を目にしたことで、少しはサーバに「入る」という言葉のイメージがつきましたでしょうか？

=== SSHとは？

EC2のインスタンスを作成する途中、ステップ6でセキュリティグループを「SSHでの接続はどこからでも通す」という設定にしたのを覚えていますか？

ここで、この「SSH」について少し説明をします。SSH@<fn>{secureShell}とはデータセンターにある@<ttb>{サーバと自分が使っている目の前のパソコンをセキュアに繋いでくれる}サービスのことです。@<chapref>{infraAndServer}で「サーバとはクライアントに対してサービスを提供するものである」という説明をしました。聞きなれないかも知れませんが、実は「SSHが動いているサーバ」のことを@<ttb>{SSHサーバ}と呼びます。

//footnote[secureShell][Secure Shellの略。]

ビアサーバは客に対してビールを提供するもので、ウェブサーバは客に対してウェブページを提供するものでしたが、SSHサーバはいったい何のサービスを提供してくれるのでしょう？

SSHは「サーバに入れて」とリクエストされたら、その人が誰なのか確認した上でサーバに入れてくれます。つまりSSHサーバは、サーバへアクセスしてきた客に対して@<ttb>{「ネットワークを介してサーバにログインできる」というサービスを提供}しているのです。

SSHと似ている仕組みに「FTP」@<fn>{ftp}や「Telnet」@<fn>{telnet}があります。定番FTPクライアントである「FFFTP」なら使ったことがある、という方もいるのではないでしょうか。このFTPやTelnetでは通信内容が暗号化されずにそのまま送られるため、通信経路を盗聴すればアカウントやパスワードは丸見えになってしまう、という問題点がありました。自分のパソコンからサーバまでの道のりを通信データが丸裸で流れていってしまうようなイメージです。

//footnote[ftp][File Transfer Protocolの略。]
//footnote[telnet][Telecommunication networkの略。]

それに対してSSHはデータを暗号化した上でやり取りできます。通信データはきちんと全身タイツを着て正体が見えない状態で流れていくので、たとえ盗聴されても暗号化する前のデータがどんなものだったのかはすぐには分かりません。そのためサーバにファイルをアップロードしたりダウンロードしたりするときには、このSSHの機能を用いた「SFTP」@<fn>{sftp}や「SCP」@<fn>{scp}というファイル転送の仕組みがよく使われます。

//footnote[sftp][SSH File Transfer Protocolの略。]
//footnote[scp][Secure Copyの略。]

このような理由からサーバにはSSHで入ります。

=== パスワード認証と鍵認証

サーバにSSHで入るときには、そのユーザが本人かどうかを確認する方法として「パスワード認証」や「鍵認証」が用いられることが多いです。

パスワード認証では、ユーザ名とパスワードを使ってサーバに入ります。鍵認証の場合はあらかじめサーバに鍵穴を設置しておいて、パソコンの中にある鍵を使ってサーバに入ります。鍵穴と鍵@<fn>{whatIsKeypair}のペアなので「キーペア」と呼ばれているのですね。この鍵というのが皆さんが先ほどダウンロードした「start-aws-keypair.pem」のことなのです。

//footnote[whatIsKeypair][鍵穴は「公開鍵」あるいは「パブリックキー」、鍵は「秘密鍵」あるいは「プライベートキー」と呼ばれます。]

先ほど作ったEC2のインスタンスには、すでに鍵穴は設置されているので、鍵（start-aws-keypair.pem）を使えばSSHの鍵認証でサーバに入ることができます。

=== 接続先となるサーバのIPアドレス

サーバに「入る」ということのイメージが付いたところで、接続先となるサーバのIPアドレスを確認してみましょう。

先ほど作成したインスタンスを選択して、下部の詳細タブ（@<img>{instanceIPv4PublicAddress}）にある「パブリックIPv4アドレス」をメモ（@<table>{IPv4Address}）してください。

//image[instanceIPv4PublicAddress][「詳細」タブの「パブリックIPv4アドレス」をメモしておこう][scale=0.8]{
//}

//table[IPv4Address][インスタンスのパブリックIPv4アドレス]{
例	パブリックIPv4アドレス
------------------------------------
18.183.107.76	
//}

「パブリックIPv4アドレス」のところにある四角いマークをクリックすると、クリップボードにコピー（@<img>{memoIPv4Address}）できますので、パソコンの中のメモ帳などにもメモしておくと便利です。

//image[memoIPv4Address][パソコンの中のメモ帳などにもメモしておく][scale=0.8]{
//}

それではメモしたIPアドレスを使ってサーバに入ってみましょう。

== SSHでサーバに入ってみよう

=== お使いのパソコンがWindowsの場合

Windowsのパソコンを使っている方は、デスクトップの「rlogin_x64」というフォルダの中にある「RLogin.exe」（@<img>{startRLogin01}）をダブルクリックしてRLoginを起動（@<img>{startRLogin02}）してください。起動したら「新規」をクリックします。

//image[startRLogin01][RLogin.exeをダブルクリック][scale=0.6]{
//}

//image[startRLogin02][RLoginが起動したら「新規」をクリック][scale=0.8]{
//}

初めに「エントリー（上）/コメント（下）」に「start-aws-instance」と入力します。続いて「ホスト名（サーバーIPアドレス）」に先ほどメモした「パブリックIPv4アドレス」を入力（@<img>{startRLogin03}）します。「ログインユーザー名」には「ec2-user」と入力してください。ec2-userというのはAmazon Linux 2のAMIを使ってインスタンスを作成すると、最初から存在しているユーザです。

//image[startRLogin03][「ホスト名（サーバーIPアドレス）」と「ログインユーザー名」を入力][scale=0.6]{
//}

続いて「SSH認証鍵」をクリック（@<img>{startRLogin04}）して、デスクトップなど絶対に忘れない場所に保存しておいた「start-aws-keypair.pem」を選択したら「開く」をクリックします。

//image[startRLogin04][「SSH認証鍵」をクリックして「start-aws-keypair.pem」を選択][scale=0.8]{
//}

次に左メニューで「プロトコル」を選択（@<img>{startRLogin05}）したら、「KeepAliveパケットの送信間隔(sec)」にチェックを入れておきます。これを設定しておくとターミナルをしばらく放っておいても接続が勝手に切れません。

//image[startRLogin05][「KeepAliveパケットの送信間隔(sec)」にチェックを入れる][scale=0.6]{
//}

続いて左メニューで「クリップボード」を選択（@<img>{startRLogin06}）したら、「左クリックの範囲指定だけでクリップボードにコピーする」と「コピー時に範囲指定を解除しない」にチェックを入れて「右クリックでペースト」を選択します。

//image[startRLogin06][右クリックや左クリックの設定][scale=0.6]{
//}

次に左メニューで「フォント」を選択（@<img>{startRLogin07}）したら、文字セットを「UTF-8」に変更します。すべて設定できたら「OK」をクリックしてください。

//image[startRLogin07][文字セットを「UTF-8」に変更][scale=0.6]{
//}

これで設定が保存できました。今やった設定は最初の1回のみで、2回目以降は不要です。それでは「OK」をクリック（@<img>{startRLogin08}）してください。

//image[startRLogin08][設定が保存できたら「OK」をクリック][scale=0.8]{
//}

すると初回のみ、この「公開鍵の確認」が表示（@<img>{startRLogin09}）されますので、「接続する」をクリック@<fn>{first}します。下部の［この公開鍵を信頼するリストに保存する］にチェックが入っていると、RLoginがサーバ固有のフィンガープリント@<fn>{fingerprint}を覚えてくれます。そして次回以降は「これはこのサーバで過去に信頼した公開鍵と同じだ」と判断して、RLoginがそのままサーバへ接続させてくれます。

//footnote[first][今後、別のパソコンから同じサーバへ接続する際には、元のパソコンに保存されているサーバのフィンガープリントと、初回接続時に表示されるフィンガープリントを比較することで、DNSキャッシュポイズニングなどの攻撃によって、他のサーバに誘導されていないか確認できます。]
//footnote[fingerprint][公開鍵のハッシュ値のことをフィンガープリント（指紋）と呼びます]

//image[startRLogin09][「公開鍵の確認」が表示されたら「接続する」をクリック][scale=0.6]{
//}

続いて「信頼するホスト鍵のリストを更新しますか？」と聞かれたら「はい」をクリック（@<img>{startRLogin10}）してください。

//image[startRLogin10][「信頼するホスト鍵のリストを更新しますか？」と表示されたら「はい」をクリック][scale=0.8]{
//}

「Amazon Linux 2 AMI」と表示（@<img>{startRLogin11}）されたら無事サーバに入れています。SSHでのログイン成功、おめでとうございます！

//image[startRLogin11][「EC2」というアスキーアートが表示されたら成功！][scale=0.8]{
//}

もし「Amazon Linux 2 AMI」と表示されず、代わりに「SSH2 User Auth Failure "publickey,gssapi-keyex,gssapi-with-mic" Status=1004 Send Disconnect Message...」というようなエラーメッセージが表示（@<img>{startRLogin12}）されてしまったら、これは「鍵がない人は入れないよ！」とお断りされている状態です。恐らく「SSH認証鍵」をクリックして「start-aws-keypair.pem」を選択する作業を忘れているものと思われますので「SSH認証鍵」の設定を確認してみてください。

//image[startRLogin12][このエラーが表示されたら「SSH認証鍵」の設定を確認しよう][scale=0.6]{
//}

「接続済みの呼び出し先が一定の時間を過ぎても正しく応答しなかったため、接続できませんでした。」というエラーメッセージが表示（@<img>{startRLogin13}）されてしまった場合は、「ホスト名（サーバーIPアドレス）」に書いた「パブリックIPv4アドレス」が間違っているものと思われます。「ホスト名（サーバーIPアドレス）」のIPアドレスを確認してみてください。

//image[startRLogin13][このエラーが表示されたらIPアドレスを確認しよう][scale=0.8]{
//}

=== お使いのパソコンがMacの場合

Macを使っている方は、ターミナル（@<img>{mac04}）を起動してください。

//image[mac04][最初からインストールされている「ターミナル」を使おう][scale=0.8]{
//}

ターミナルがどこにあるのか分からないときは、Macの画面で右上にある虫眼鏡のマークをクリックして、Spotlightで「ターミナル」と検索（@<img>{mac05}）すれば起動できます。

//image[mac05][どこにあるのか分からなかったらSpotlightで「ターミナル」と検索][scale=0.8]{
//}

そして開いたターミナルで次の文字を入力してReturnキーを押します。これはサーバに入るときに使う鍵をオーナー以外が使えないよう、chmodというコマンドで読み書き権限を厳しくしています。この作業は最初の1回だけで構いません。もし「start-aws-keypair.pem」を保存した場所がデスクトップ@<fn>{tilde}以外の場合は適宜書き換えてください。

//cmd{
chmod 600 ~/Desktop/start-aws-keypair.pem
//}

//footnote[tilde][ちなみに~（チルダ）はホームディレクトリを表すので「~/Desktop/start-aws-keypair.pem」は「/Users/<ユーザ名>/Desktop/start-aws-keypair.pem」と同じ意味です。]

続いてターミナルで次の文字を入力したら再びReturnキーを押します。「パブリックIPv4アドレス」の部分は先ほどメモした「パブリックIPv4アドレス」に書き換えてください。-iオプションは「サーバにはこの鍵を使って入ります」という意味ですので、「start-aws-keypair.pem」を保存した場所がデスクトップ以外だった場合はこちらも適宜書き換えてください。

//cmd{
ssh ec2-user@パブリックIPv4アドレス -i ~/Desktop/start-aws-keypair.pem

# 例：パブリックIPv4アドレスが「18.183.107.76」の場合
ssh ec2-user@18.183.107.76 -i ~/Desktop/start-aws-keypair.pem
//}

すると初回のみ、次のようなメッセージが表示されますので、「yes」と打ってReturnキーを押してください。@<fn>{firstMac}これによってサーバ固有のフィンガープリント@<fn>{fingerprintMac}を記憶して、次回以降は「これはこのサーバで過去に信頼した公開鍵と同じだ」と判断して、そのままサーバへ接続させてくれます。

//footnote[firstMac][今後、別のMacから同じサーバへ接続する際には、元のMacに保存されているサーバのフィンガープリントと、初回接続時に表示されるフィンガープリントを比較することで、DNSキャッシュポイズニングなどの攻撃によって、他のサーバに誘導されていないか確認できます。]
//footnote[fingerprintMac][公開鍵のハッシュ値のことをフィンガープリント（指紋）と呼びます]

//cmd{
Are you sure you want to continue connecting (yes/no)?
//}

「Amazon Linux 2 AMI」と表示されたら無事サーバに入れています。おめでとうございます！

=== サーバをシャットダウンしてみよう

折角サーバにログインできたので早速コマンド（命令）を打ってみましょう。できれば普段は絶対に打つ機会のないような…そうだ！

//cmd{
sudo shutdown -h now
//}

と入力したらEnterキー（もしくはReturnキー）を押してください。（@<img>{shutdownServer}）これはサーバを今すぐシャットダウンするコマンドです。サーバ停止が気軽に試せるのは勉強用のインスタンスならではですね。

//image[shutdownServer][サーバをシャットダウンしてみよう][scale=0.8]{
//}

Enterキーを押したらサーバがシャットダウンされてSSHの接続も切れてしまいました。それではちゃんとシャットダウンできたのか、マネジメントコンソールからも確認してみましょう。EC2ダッシュボードで左メニューの「インスタンス」を選択（@<img>{instanceStopped}）したら、上部の更新マークをクリックしてください。シャットダウンしたのでインスタンスの状態が「停止済み」になっています。

//image[instanceStopped][EC2ダッシュボード＞左メニューの「インスタンス」＞更新マークをクリック][scale=0.8]{
//}

それでは止まってしまったサーバを再起動しましょう。インスタンスにチェックを入れたら、「インスタンスの状態」で「インスタンスを開始」をクリック（@<img>{startInstance01}）してください。

//image[startInstance01][アクション＞インスタンスの状態＞開始をクリック][scale=0.8]{
//}

「正常に開始しました」と表示されます。インスタンスの状態が「保留中」を経て「実行中」になるまで少し待ちます。なかなか「実行中」にならない場合は、上部の更新マークをクリック（@<img>{startInstance03}）してみてください。

//image[startInstance03][インスタンスの状態が「実行中」になるまで少し待つ][scale=0.8]{
//}

インスタンスの状態が「実行中」になったら再びサーバに入ってみましょう。Windowsの方はRLoginで左のアイコンをクリック（@<img>{RloginAgain01}）します。先ほどの「start-aws-instance」を選択したら「OK」をクリックしてください。

//image[RloginAgain01][「start-aws-instance」を選択したら「OK」をクリック][scale=0.8]{
//}

Macの方はターミナルで先ほどとまったく同じコマンド（命令）を実行してみてください。キーボードで「↑」を押すと直前に打ったコマンドが出てきますので、その状態でReturnキーを押してください。

//cmd{
ssh ec2-user@パブリックIPv4アドレス -i ~/Desktop/start-aws-keypair.pem
//}

シャットダウンして再び起動しただけで何の設定も変えてないので、すぐサーバに接続できると思ったのですが…暫く真っ黒い画面が続いた後、「接続済みの呼び出し先が一定の時間を過ぎても正しく応答しなかったため、接続できませんでした。」というエラー（@<img>{RloginAgain02}）が出て接続できなくなってしまいました。「いいえ」をクリックしてエラー画面を閉じましょう。

//image[RloginAgain02][シャットダウンして起動したらサーバに繋がらなくなった！][scale=0.8]{
//}

いわゆる「何もしてないのに壊れた！」状態ですが、いったい何が起きたのでしょう？

=== 再起動しても変わらないElasticIPをつけよう

急にサーバに入れなくなった原因を探るべく、再びEC2ダッシュボードでインスタンスの状態を見てみましょう。（@<img>{RloginAgain03}）Rloginのエラーメッセージには「呼び出し先が応答しなかった」とありましたが、インスタンスはちゃんと起動しています。

では「パブリックIPv4アドレス」に注目してみてください。何か気づきませんか？

//image[RloginAgain03][「パブリックIPv4アドレス」に注目してみよう][scale=0.8]{
//}

先ほど自分でメモした「パブリックIPv4アドレス」と、今表示されている「パブリックIPv4アドレス」を比較（@<table>{IPv4AddressDiff}）してみてください。

//table[IPv4AddressDiff][インスタンスのパブリックIPv4アドレスを比較]{
シャットダウン前のパブリックIPv4アドレス	現在のパブリックIPv4アドレス
------------------------------------
18.183.107.76	3.112.123.2
//}

そうなんです。シャットダウンする前と、起動しなおした今の「パブリックIPv4アドレス」を比較すると、@<ttb>{まったく別のIPアドレスになっている}のです。

実はEC2においてIPアドレスは動的なものです。つまりインスタンスが停止されると、そのインスタンスに紐づいていたIPアドレスは解放されてしまい、インスタンスが再起動されるとまた新しいIPアドレスが紐付けられる、というのがEC2におけるIPアドレスの仕様@<fn>{reboot}なのです。会社にたとえると、毎日19時に仕事を終えてオフィスのブレーカーを落として帰ると、翌日出社して電気をつけたときには代表電話番号が昨日とは違うものに変わっている、というような感じです。毎日「弊社の電話番号が変わりまして。今日の番号はこれです」とクライアントへ連絡するのは嫌ですね…。

//footnote[reboot][ちなみに再起動であれば「パブリックIPv4アドレス」は変わりません。シャットダウンして起動しなおしたときだけ変わってしまいます。]

このままだとサーバをシャットダウンして起動するたびに「サーバに繋がらなくなった！」と大騒ぎしてEC2ダッシュボードで新しい「パブリックIPv4アドレス」を確認する破目になります。そうならないようElasticIPという静的な（＝勝手に変わらない）IPアドレスのサービスでサーバに固定のIPアドレスをつけましょう。

EC2ダッシュボードの左メニューで「ネットワーク&セキュリティ」の中にある「Elastic IP」をクリック（@<img>{startaws3}）してください。まだElastic IPがひとつもないため、「このリージョンにはElastic IPアドレスがありませんでした」と表示されます。「Elastic IPアドレスの割り当て」をクリックします。

//image[startaws3][「Elastic IPアドレスの割り当て」をクリック][scale=0.8]{
//}

「割り当て」をクリック（@<img>{startaws5}）します。

//image[startaws5][「割り当て」をクリック][scale=0.6]{
//}

「Elastic IPアドレスが正常に割り当てられました。」と表示（@<img>{startaws6}）されます。これでElastic IPを手に入れましたが、手に入れたElastic IPをまだインスタンスにくっつけていないので、紐付ける作業をしましょう。「このElastic IPアドレスを関連付ける」をクリックしてください。

//image[startaws6][「このElastic IPアドレスを関連付ける」をクリック][scale=0.8]{
//}

リソースタイプは「インスタンス」のままで構いません。インスタンスは「インスタンスタイプを選択します」と書かれた箇所をクリックすると、下に先ほど作った「start-aws-instance」が表示されるのでクリック（@<img>{startaws8}）します。

//image[startaws8][「start-aws-instance」をクリック][scale=0.6]{
//}

プライベート IPは「プライベートIPの選択」と書かれた箇所をクリックすると、「start-aws-instance」のプライベートIPアドレス@<fn>{privateIp}が表示されるのでクリック（@<img>{startaws9}）します。

//footnote[privateIp][パブリックIPアドレスは「03-○○○○-○○○○」のような外線番号で、プライベートIPアドレスは「法務部の片岡さんは4322で、総務部の茂木さんは2652」のような内線番号だと思ってください。詳しくは「DNSをはじめよう 改訂第2版」の「【コラム】このIPアドレスはグローバルIP？プライベートIP？」で説明しています。]

//image[startaws9][「start-aws-instance」のプライベートIPアドレスをクリック][scale=0.6]{
//}

再関連付けにチェックは入れません。この状態（@<img>{startaws10}）で「関連付ける」をクリックしてください。

//image[startaws10][「関連付ける」をクリック][scale=0.8]{
//}

「Elastic IPアドレスが正常に関連付けられました。」と表示（@<img>{startaws11}）されたら、Elastic IPとインスタンスを紐付ける作業は完了です。

//image[startaws11][「Elastic IPアドレスが正常に関連付けられました。」と表示された][scale=0.8]{
//}

下部の「割り当てられたIPv4アドレス」に表示されているElastic IPをしっかりメモ（@<table>{ElasticIPAddress}）しておきましょう。四角いマークをクリックすると、クリップボードにコピー（@<img>{startaws14}）できますので、パソコンの中のメモ帳などにもメモしておくと便利です。

//image[startaws14][Elastic IPをしっかりメモしておこう][scale=0.8]{
//}

//table[ElasticIPAddress][Elastic IPをメモ]{
例	Elastic IP
------------------------------------
54.168.11.169	　　　　　　　　　　　　　
//}

これでインスタンスに「シャットダウン＆起動しても勝手に変わらないIPアドレス」がついたので、今後、RLoginやターミナルでサーバに接続するとき@<fn>{bastion}はこのIPアドレスをずっと使えます。

//footnote[bastion][今回はサーバが1台だけなので直接ログインしていますが、通常は踏み台サーバ（英語だとBastion hostと呼ばれることが多い）を用意して、個々のウェブサーバやデータベースサーバには踏み台を経由しないと入れない、という構成にすることが多いです。サーバは大切な箱入り娘なので、怖いお父さん（踏み台サーバ）を介さないと話しかけられないようにすることで安全性を高めているのです。]

でも折角つけたElasticIPですが、この「54.168.11.169」のような数字の羅列を覚えたり、SSHでログインするたびに打ち込むのはちょっと面倒ですよね。皆さんも普段電話をかけるときに電話番号をいちいち打つのは面倒なので、アドレス帳に名前と電話番号を登録していますよね。それと同じようにネームサーバにドメイン名とIPアドレスの紐付けを登録しておけば、そのドメイン名を使ってサーバに入れるようになります。

皆さんは「DNSをはじめよう」で買った自分のドメイン名を持っているので、早速ドメイン名とIPアドレスの組み合わせをネームサーバに登録してみましょう。ドメイン名の登録はRoute53で行います。

=== サーバに入るときに使うドメイン名を作ろう

マネジメントコンソールの左上にある「サービス」から、「ネットワーキング＆コンテンツ配信」の下にある「Route53」（@<img>{startaws15}）をクリックしてください。

//image[startaws15][サービス＞ネットワーキング＆コンテンツ配信＞Route53][scale=0.8]{
//}

Route53ダッシュボードを開いたらDNS管理の「ホストゾーン」をクリック（@<img>{startaws16}）します。

//image[startaws16][「ホストゾーン」をクリック][scale=0.8]{
//}

「ドメイン名」の列にある自分のドメイン名（筆者の場合はstartdns.fun）をクリック（@<img>{startaws17}）します。@<fn>{hostedZone}

//image[startaws17][自分のドメイン名をクリック][scale=0.8]{
//}

//footnote[hostedZone][ここに自分のドメイン名が表示されていなかったら、前作「DNSをはじめよう」の「3.3.1 Route53でホストゾーンを作成」という手順を飛ばしているものと思われます。]

新しくリソースレコード@<fn>{rr}を作りたいので「レコードを作成」をクリック（@<img>{startaws18}）してください。

//image[startaws18][「レコードを作成」をクリック][scale=0.8]{
//}

//footnote[rr][リソースレコードってなんだっけ？と思ったら「DNSをはじめよう」の「2.4 リソースレコード」を参照。]

「レコードのクイック作成」が表示されたら、レコード名には「login」、値には先ほどメモしたElastic IPを入力（@<img>{startaws19}）してください。それ以外の箇所は何も変更せずそのままで構いません。入力できたら「レコードを作成」をクリックします。

//image[startaws19][レコード名には「login」、値には先ほどメモしたElastic IPを入力][scale=0.8]{
//}

「startdns.fun のレコードが正常に作成されました。」と表示されます。これで「login.自分のドメイン名」（@<img>{startaws20}）というAレコードが作成できました。

//image[startaws20][「login.自分のドメイン名」というAレコードができた][scale=0.8]{
//}

ではこのドメイン名を使って再びサーバにログインしてみましょう。Windowsの方はRLoginで左のアイコンをクリック（@<img>{startaws21}）してから「編集」をクリックしてください。「ホスト名（サーバーIPアドレス）」を先ほど作ったドメイン名の「login.自分のドメイン名」に変更（@<img>{startaws22}）したらOKをクリックします。

//image[startaws21][「編集」をクリック][scale=0.8]{
//}

//image[startaws22][「ホスト名（サーバーIPアドレス）」を「login.自分のドメイン名」にしてOKをクリック][scale=0.8]{
//}

「start-aws-instance」を選択（@<img>{startaws23}）したら「OK」をクリックしてください。

//image[startaws23][「start-aws-instance」を選択したら「OK」をクリック][scale=0.8]{
//}

この「login.自分のドメイン名」という名前でサーバに接続するのは初めてなので、また「公開鍵の確認」が表示（@<img>{startaws24}）されますが「接続する」をクリックしてください。

//image[startaws24][「公開鍵の確認」が表示されたら「接続する」をクリック][scale=0.6]{
//}

続いて「信頼するホスト鍵のリストを更新しますか？」と聞かれたら「はい」をクリック（@<img>{startaws25}）してください。

//image[startaws25][「信頼するホスト鍵のリストを更新しますか？」と表示されたら「はい」をクリック][scale=0.8]{
//}

「Amazon Linux 2 AMI」と表示（@<img>{startaws26}）されましたか？無事にドメイン名を使ってサーバに入れました。Windowsの皆さん、おめでとうございます！

//image[startaws26][ドメイン名を使ってサーバに入れた！][scale=0.8]{
//}

Macの方はターミナルを起動して次のコマンドを実行してください。「キーボードで「↑」を押すと直前に打ったコマンドが出てきますので、アットマークの後ろElastic IPアドレスから「login.自分のドメイン名」に変更してReturnキーを押してください。

//cmd{
ssh ec2-user@login.自分のドメイン名 -i ~/Desktop/start-aws-keypair.pem
//}

こちらもこの「login.自分のドメイン名」という名前でサーバに接続するのは初めてなので、次のようなメッセージが表示されます。「yes」と打ってReturnキーを押してください。

//cmd{
Are you sure you want to continue connecting (yes/no)?
//}

「Amazon Linux 2 AMI」と表示されたら、無事にドメイン名を使ってサーバに入れました。Macの皆さんもおめでとうございます！

今後は今やったのと同じやり方をそのまま繰り返せばサーバにログインできます。ドメイン名というとどうしても「ブラウザで入力してサイトを見るときに使うもの」というイメージがありますが、「名前からIPアドレスが引けるもの」なのでこういう使い方もできるのです。

== ターミナルでサーバを操作・設定してみよう

ようやくサーバに安定して入れるようになったので、ここからはターミナルの基本的な操作を試してみましょう。

=== ターミナルの基本操作に慣れよう

==== プロンプトとは？

では黒い画面で何回かEnterキー（あるいはReturnキー）を押してみましょう。（@<img>{startaws27}）普通に改行されますよね。

//image[startaws27][Enterキーを押すと改行されて、プロンプトが常に表示されている][scale=0.8]{
//}

このとき左側にずっと出ている次のような表示は「プロンプト」といって、ログインしているユーザ名やサーバの名前などが表示されています。

//cmd{
[ec2-user@ip-172-31-34-113 ~]$
//}

プロンプトを見ると今は「ec2-user」という一般ユーザであることが分かります。これからサーバに色んな設定をしたいのですが、一般ユーザだと権限がないので「root」という全権限をもったユーザになりましょう。

//cmd{
$ sudo su -
//}

と書いてEnterキーを押すとrootになれます。（@<img>{startaws28}）「$」はプロンプトを表していますので入力しないでください。rootになれたらまた何回かEnterキーを押して改行してみましょう。

//image[startaws28][sudo su -を書いてEnterキーを押すとrootになれる][scale=0.8]{
//}

いちばん左側に出ているプロンプトが次のように変化しましたか？

//cmd{
[root@ip-172-31-34-113 ~]#
//}

ユーザ名が「ec2-user」から「root」に変わりました。それからいちばん右の部分も「$」から「#」に変わっています。プロンプトは@<ttb>{一般ユーザだと「$」、全権を持っているrootだと「#」}という表示になります。今後は「このコマンドをrootで実行してください」のように実行ユーザを詳しく書くことはしませんので、例として書いてある部分のプロンプトが「$」だったらec2-userのような一般ユーザで実行、「#」だったらrootで実行するんだ、と思ってください。例に「$」や「#」が書いてあってもターミナルで@<ttb>{「$」や「#」を自分で入力する必要はありません}。

==== コマンドは失敗したときだけエラーを吐く

前述の「sudo su -」のようなものを「コマンド」と呼びます。コマンドとはサーバに対して「あれをして」「これをして」と頼む命令のようなものです。サーバでコマンドを打った場合、基本的に@<ttb>{上手くいったときは何も言わないで、失敗したときだけエラーを吐きます}。ですのでコマンドを打った時に何も表示されなくても不安にならなくて大丈夫です。

先ほどの「私をrootにして！」という命令である「sudo su -」も、上手くいって、ちゃんとrootになれたのでメッセージは一切出ていないですよね。これが「sudo」を打ち間違えて、こんな風に実行するとどうなるでしょう？

//cmd{
$ sudooo su -
//}

「sudoooなんてコマンドは見つからなかったよ」というエラーメッセージ（@<img>{startaws29}）が表示されました。

//image[startaws29][「sudooo: command not found」というエラーが表示された][scale=0.8]{
//}

このように何か失敗したときだけエラーメッセージが出ます。英語でエラーが出るとそれだけでパニックになってしまいますが、落ち着いてゆっくり読めば「sudooo: command not found…ああ、sudoooっていうコマンドが見つかりませんでした、って書いてある」と判読できると思います。@<ttb>{エラーが出たら声に出してゆっくり読んでみましょう}。

==== コピー＆ペーストするには？

===== Windowsの場合

ターミナルで表示されている内容をコピーしたいときは、RLoginならコピーしたい部分を@<ttb>{マウスで選択するだけ}です。（@<img>{startaws30}）選択してからCtrl+cを押す必要はありません。逆にコピーした内容をターミナルへペーストしたいときは、ターミナル上で@<ttb>{右クリックするだけ}です。Ctrl+vは使えないので注意してください。

//image[startaws30][RLoginならマウスで選択するだけでコピーできる][scale=0.8]{
//}

===== Macの場合

Macのターミナルの場合は、コピーしたい部分をマウスで選択した上でCtrl+cもしくはCommand+cでコピーできます。ペーストしたいときは、Ctrl+vまたはCommand+vでペーストできます。

==== ターミナルを閉じたいとき

もう今日の勉強は終わり！サーバとの接続を切ってターミナルを閉じたい、というときはexit（イグジット）というコマンドを叩きます。

//cmd{
# exit
//}

rootになっているときにexitを叩くとec2-userに戻れます。そしてec2-userで再びexitを叩くと、サーバの接続を切ってターミナルを閉じることができます。

//cmd{
$ exit
//}

exitをせずに右上の赤い×を押してウィンドウを閉じるのは、電話を切るときに、通話オフのボタンを押さずにいきなり電話線を引っこ抜くような乱暴な切り方なのでお勧めしません。

=== ミドルウェアをインストール

それでは必要なミドルウェアをインストールしていきましょう。最初にrootになっておいてください。インストールするときはyum（ヤム）@<fn>{dnf}というコマンドを使います。

//footnote[dnf][ちなみにAmazon Linux 2（CentOS 7系）までは、yumコマンドを使ってインストールしますが、Cent OS8系になるとdnfコマンドに変わります。dnfは"DaNdiFied yum"（めかしこんだyum）の略で、名前のとおりyumの後継コマンドです。]

//cmd{
$ sudo su -
//}

先ずはyumで色々アップデートしておきましょう。Windowsアップデートみたいなものです。最後に「Complete!」と表示されたら問題なく完了しています。ちなみに-yオプションはYESを意味するオプションです。-yオプションをつけないで実行すると「これとこれを更新するけどいい？ダウンロードサイズとインストールサイズはこれくらいだよ」という確認が表示されて、yと入力してEnterキーを押さないと更新されません。どんな表示がされるのか先ずは確認したい、という場合は末尾の-yを外して一度試してみてもいいでしょう。

//cmd{
# yum update -y
//}

次に「DNSをはじめよう」で出てきたwhoisコマンドを入れます。こちらも最後に「Complete!」と表示されればOKです。

//cmd{
# yum install whois -y
//}

今度はMySQLのYumリポジトリ@<fn>{mysqlYumRepos}を追加した上で、データベース接続時に必要なMySQLクライアントを入れておきます。それぞれ最後に「Complete!」と表示されればOKです。

//footnote[mysqlYumRepos][yumコマンドをたたいたとき、一体どこからwhoisコマンドやMySQLクライアントを連れてきてくれてるんだろう、と不思議に思いませんか？思いますよね。思う前提で話を進めます。あなたがyumコマンドをたたくと、「Yumリポジトリ」という場所から指定されたミドルウェアのパッケージを連れてきます。どこのYumリポジトリへ探しに行くかは「/etc/yum.repos.d/」の下にあるファイルで設定されています。探しに行った先のYumリポジトリに指定のパッケージがなければ、"No package ○○ available."（○○は入手できなかったよ）というメッセージが出てインストールはできません。ないものはインストールできないのです。今回はMySQLクライアントをインストールしたいのですが、Amazon Linux 2でもともと設定されている「Amazon Linux 2 core repository」というYumリポジトリには、MySQLクライアントが存在しないため、MySQLクライアントが存在しているMySQLのYumリポジトリを、探しに行く先として追加します。 @<href>{https://dev.mysql.com/downloads/repo/yum/}]

//cmd{
# yum install https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm -y
# yum install mysql-community-client -y
//}

WordPressを動かすために必要なPHP7.4@<fn>{php74}も入れます。

//footnote[php74][普通に入れようとするとPHP5.4になってしまうので、amazon-linux-extrasコマンドを使って、amazon-linux-extrasリポジトリからPHP7.4をインストールします。 @<href>{https://aws.amazon.com/jp/premiumsupport/knowledge-center/ec2-install-extras-library-software/}]

//cmd{
# amazon-linux-extras install php7.4 -y
# yum install php php-mbstring -y
//}

ウェブサーバとして動かすためのApache2.4@<fn>{version}も入れます。

//footnote[version][サーバに入っているPHPやApacheのバージョンがいくつなのか、という情報は大切です。今後、あなたがPHPのソースコードやApacheの設定ファイルを書こうと思って、インターネットで書き方を調べたとき、PHP5の関数やApache2.2の設定方法を参考にしてしまうと、PHP7.4やApache2.4の環境では上手く動かない可能性があります。]

//cmd{
# yum install httpd -y
//}

Apacheの正式名称は「Apache HTTP Server」です。ちょっと分かりにくいかも知れませんが、パソコンにMicrosoft Excelをインストールしたら「表計算というサービスが提供できるパソコン」になるのと同じで、サーバにこのApacheをインストールすると「リクエストに対してウェブページを返すサービスが提供できるサーバ」、つまりウェブサーバになります。 今回はApacheを入れましたがウェブサーバのミドルウェアは他にも色々な種類があります。

インストールが終わったので、サーバを起動した際にApacheが自動で立ち上がってくるよう、自動起動の設定もしておきましょう。systemctlコマンドで、httpd（Apacheのこと）を起動させると共に、自動起動を有効にしておきます。

//cmd{
# systemctl enable --now httpd
Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/lib/systemd/system/httpd.service.
//}

自動起動の設定ができたか確認してみましょう。enabled（有効）と表示されれば問題ありません。

//cmd{
# systemctl is-enabled httpd
enabled
//}

ウェブサーバが起動したか、ちょっと確認してみましょう。curl（カール）という「ターミナルにおけるブラウザ」のようなコマンドを使って、localhost（自分自身）に「ページを見せて」とリクエストをしてみます。

//cmd{
# curl localhost
//}

ずらずらずらーっとHTMLが表示されて、最後の行が@<ttb>{</html>}で終わっていたら問題ありません。「ウェブページを見せてください」というあなたのリクエストに対して、ちゃんと「ウェブページ」というレスポンスが返ってきています。

=== OSの基本設定をしておこう

==== タイムゾーンの設定

date（デート）コマンドでサーバの時間を確認してみましょう。日本はいま22日の深夜0:32なのですが、サーバの時間は21日の15:14で9時間ずれてしまっています。

//cmd{
# date
Mon Dec 21 15:32:28 UTC 2020
//}

日本時間@<fn>{jst}になるようタイムゾーンの変更を行いましょう。

//footnote[jst][日本標準時（JST）は、協定世界時（UTC）から9時間進めた時間、つまりUTC+9ですね。]

//cmd{
# vi /etc/sysconfig/clock
//}

vi（ブイアイ）@<fn>{remoteSsh}はテキストファイルを編集するためのコマンドです。viコマンドでファイルを開くと、最初は次のような「閲覧モード」の画面（@<img>{startaws31}）が表示されます。閲覧モードは「見るだけ」なので編集ができません。

//footnote[remoteSsh][本書ではこの先もずっとターミナルからviコマンドでファイルを編集していきますが、「viつらい…」という人のために他の方法もご紹介しておきます。もしあなたがパソコンでVisual Studio Codeというエディタをお使いでしたら、公式（Microsoft）が提供している「Remote - SSH」という拡張機能を入れることで、Visual Studio Code上でサーバにログインして、サーバの中にあるテキストファイルを直接Visual Studio Codeで編集したり保存したりできる機能があります。コードがシンタックスハイライトされて、可読性も一気に上がるのでお勧めです。詳しくは公式ドキュメントの「Remote development over SSH」を参照してください。 @<href>{https://code.visualstudio.com/docs/remote/ssh-tutorial}]

//image[startaws31][viコマンドでファイルを開いた][scale=0.8]{
//}

この状態でi（アイ）を押すと「編集モード」@<fn>{insertMode}に変わります。（@<img>{startaws32}）左下に「-- INSERT --」と表示されていたら「編集モード」です。

//footnote[insertMode][ここでは初心者の方でも直感的に分かるよう「閲覧モード」「編集モード」と呼んでいますが、正しくは「ノーマルモード」「インサートモード」です。]


//image[startaws32][i（アイ）を押すと「-- INSERT --」と表示される「編集モード」になった][scale=0.8]{
//}

「編集モード」になるとファイルが編集できるようになります。それでは「ZONE="UTC"」を「ZONE="Asia/Tokyo"」（@<img>{startaws33}）に書き換えてください。

//image[startaws33][「ZONE="UTC"」を「ZONE="Asia/Tokyo"」に書き換える][scale=0.8]{
//}

「編集モード」のままだと保存ができないので書き終わったらESCキーを押します。すると左下の「-- INSERT --」が消えて再び「閲覧モード」になります。（@<img>{startaws34}）

//image[startaws34][ESCを押すと左下の「-- INSERT --」が消えて再び「閲覧モード」になる][scale=0.8]{
//}

「閲覧モード」に戻ったら「:wq」@<fn>{wq}と入力してEnterキーを押せば変更が保存されます。（@<img>{startaws35}）

//image[startaws35][「:wq」と入力してEnterキーを押せば保存される][scale=0.8]{
//}

//footnote[wq][書き込んで（write）、抜ける（quit）という命令なのでwqです。]

色々やっているうちになんだか訳が分からなくなってしまって「今の全部なかったことにしたい！取り合えずviからいったん抜けたい！」と思ったときは、ESCキーを押して「:q!」@<fn>{q}と入力してEnterキーを押すと変更を保存せずに抜けることができます。

//footnote[q][保存せずに強制終了（quit!）という命令なのでq!です。]

編集できたらcat（キャット）コマンド@<fn>{cat}でファイルの中身を確認してみましょう。次のように表示されたら、ちゃんと編集できています。

//cmd{
# cat /etc/sysconfig/clock
ZONE="Asia/Tokyo"
UTC=true
//}

//footnote[cat][catは猫ではなく「conCATenate files and print on the standard output」の略だそうです。筆者はいつも「猫がファイルの中身を全部出して見せてくれてるんだ」と考えることでちょっぴり幸せになっています。]

さらにlnコマンド@<fn>{ln}でシンボリックリンクを作ります。シンボリックリンクはWindowsでいうところのショートカットみたいなものです。成功した場合は、画面に何も表示されませんので安心してください。

//footnote[ln][lnはlinkの略です。]

//cmd{
# ln -sf /usr/share/zoneinfo/Asia/Tokyo /etc/localtime

代わりにこれでよさそう
# timedatectl set-timezone Asia/Tokyo
/etc/sysconfig/clock は変化ない
//}

ちなみに入力しているパス（path）は入力途中でタブを押すと自動的に補完されるので、全部手打ちしなくても大丈夫です。たとえば

//cmd{
# ln -sf /usr/sh
//}

まで打ってからTabキーを押すと次のように自動補完されます

//cmd{
# ln -sf /usr/share/
//}

シンボリックリンクが生成されたかlsコマンド@<fn>{ls}で確認してみましょう。（@<img>{startaws36}）

//cmd{
# ls -l /etc/localtime
//}

//footnote[ls][lsはlistの略で、名前のとおりファイルを一覧表示してくれるコマンドです。-lはlongの略で「詳細を表示」というオプションです。]

//image[startaws36][シンボリックリンクが生成された][scale=0.8]{
//}

「->」の矢印が実体であるファイルを指しているので、シンボリックリンクができていることがわかります。

==== locale（言語）の設定

続いてlocale（言語）の設定をします。今は言語の設定が英語になっているのでエラーメッセージなども英語で表示されますが、分かりやすくするため言語設定を日本語に変更しましょう。

//cmd{
# vi /etc/sysconfig/i18n

代わりにこれでよさそう
localectl set-locale LANG=ja_JP.UTF-8
一度exitで抜けて、再度rootになる
//}

先ほどと同じviコマンドでファイルを開いたらi（アイ）で「編集モード」にして「en_US」の部分を「ja_JP」に書き換えてください。

//cmd{
# vi /etc/sysconfig/i18n
LANG=en_US.UTF-8
↓
LANG=ja_JP.UTF-8
//}

書き終わったらESCキーを押して「閲覧モード」に戻り「:wq」で保存します。編集できたらcat（キャット）コマンドでファイルの中身を確認してみましょう。

//cmd{
# cat /etc/sysconfig/i18n
LANG=ja_JP.UTF-8
//}

通常のLinuxサーバであればこの設定だけでいいのですが、Amazon Linuxの場合、AMIからインスタンスを復元@<fn>{restore}すると今修正した「LANG=ja_JP.UTF-8」がそっと元の「LANG=en_US.UTF-8」に戻ってしまいます。

//footnote[restore][「AMIからインスタンスを復元」については@<chapref>{backup}と@<chapref>{balancing}で解説します。]

元に戻らないよう次のファイルも編集しておきましょう。

//cmd{
# vi /etc/cloud/cloud.cfg
//}

viコマンドでファイルを開いたらi（アイ）で「編集モード」にして一番下に次の1行を書き足してください。

//cmd{
locale: ja_JP.UTF-8
//}

書き終わったらESCキーを押して「閲覧モード」に戻り「:wq」で保存します。編集できたらcatコマンドでファイルの中身を確認してみましょう。

//cmd{
# cat /etc/cloud/cloud.cfg
# WARNING: Modifications to this file may be overridden by files in
# /etc/cloud/cloud.cfg.d

# If this is set, 'root' will not be able to ssh in and they 
# will get a message to login instead as the default user (ec2-user)
disable_root: true

# This will cause the set+update hostname module to not operate (if true)
preserve_hostname: true

datasource_list: [ Ec2, None ]

repo_upgrade: security
repo_upgrade_exclude:
 - kernel
 - nvidia*
 - cudatoolkit

mounts:
 - [ ephemeral0, /media/ephemeral0 ]
 - [ swap, none, swap, sw, "0", "0" ]
# vim:syntax=yaml

locale: ja_JP.UTF-8
//}

==== historyの設定

最後にhistoryの設定@<fn>{better}を行います。historyコマンドを叩くと今まで自分が実行したコマンドの履歴が見られます。

//footnote[better][historyの設定は任意ですが、あとで自分の作業を振り返るときに便利なので設定しておくことをお勧めします。]

//cmd{
# history
    1  sudooo su -
    2  yum install -y jwhois mysql
    3  yum install -y php72 php72-mbstring php72-mysqlnd
    4  chkconfig --add httpd
    5  chkconfig httpd on
    6  chkconfig --list httpd
    7  date
    8  vi /etc/sysconfig/clock
    9  cat /etc/sysconfig/clock
   10  ln -sf /usr/share/zoneinfo/Asia/Tokyo /etc/localtime
   11  ls -l /etc/localtime
   12  vi /etc/sysconfig/i18n
   13  cat /etc/sysconfig/i18n
//}

とても便利なのですが、このままだと「そのコマンドをいつ実行したのか？」という日時が分かりません。また最大1000件までしか保存されないためそれ以上前の履歴を追うことができません。設定を変更して最大で2000件まで保存されて、日時も表示されるようにしましょう。

//cmd{
# vi /etc/bashrc
//}

先ほどと同じviコマンドでファイルを開くと、最初は「閲覧モード」になっています。「閲覧モード」のままでshift+gを押してファイルの最終行へ移動（@<img>{startaws37}）してください。

//image[startaws37][shift+gで最終行に移動した][scale=0.8]{
//}

最終行に移動したらi（アイ）で「編集モード」にして次の2行を追記してください。

//cmd{
HISTTIMEFORMAT='%F %T '
HISTFILESIZE=2000
//}

書き終わったらESCキーを押して「閲覧モード」に戻り「:wq」で保存します。編集できたらtail（テイル）コマンド@<fn>{tail}でファイルの中身を確認してみましょう。

//cmd{
# tail -2 /etc/bashrc
HISTTIMEFORMAT='%F %T '
HISTFILESIZE=2000
//}

//footnote[tail][tailコマンドは名前のとおりファイルの尻尾、つまり末尾を表示するコマンド。引数で「-2」と指定すれば末尾から2行、「-10」と指定すれば末尾から10行が表示されます。]

以上でOSの基本設定は終了です。変更した設定を有効にするためreboot（リブート）コマンドでサーバを再起動しておきましょう。

//cmd{
# reboot
//}

SSHの接続も切れてしまいますが、割とすぐに再起動しますので再度RLoginやターミナルで接続（@<img>{startaws38}）してみてください。今度はさっきと同じ設定でそのまま接続できるはずです。

//image[startaws38][さっきと同じ設定で接続してみよう][scale=0.8]{
//}

接続できたらdateコマンドでサーバの時間を確認してみましょう。サーバのタイムゾーンが東京になって時間のずれはなくなり、言語も日本語に変わったことで次のように表示されるはずです。

//cmd{
$ date
2018年  9月  1日 土曜日 19:58:14 JST
//}

続いてrootになってhistoryコマンドを叩いてみましょう。rootになったときのメッセージも日本語に変わっていますね。

//cmd{
$ sudo su -
最終ログイン: 2018/09/01 (土) 20:00:12 JST日時 pts/0

# history
    1  2018-09-01 20:01:41 sudooo su -
    2  2018-09-01 20:01:41 ip addr
    3  2018-09-01 20:01:41 hostname
    4  2018-09-01 20:01:41 chkconfig --add httpd
    5  2018-09-01 20:01:41 chkconfig httpd on
    6  2018-09-01 20:01:41 chkconfig --list httpd
    7  2018-09-01 20:01:41 date
    8  2018-09-01 20:01:41 vi /etc/sysconfig/clock
    9  2018-09-01 20:01:41 cat /etc/sysconfig/clock
   10  2018-09-01 20:01:41 ln -sf /usr/share/zoneinfo/Asia/Tokyo /etc/localtime
   11  2018-09-01 20:01:41 ls -l /etc/localtime
   12  2018-09-01 20:01:41 vi /etc/sysconfig/i18n
   13  2018-09-01 20:01:41 cat /etc/sysconfig/i18n
   14  2018-09-01 20:01:41 vi /etc/bashrc
   15  2018-09-01 20:01:41 tail -2 /etc/bashrc
   16  2018-09-01 20:01:41 reboot
   17  2018-09-01 20:02:58 date
   18  2018-09-01 20:03:01 history
//}

設定変更してrebootするまでは日時が記録されていなかったためすべて同じ日時になっていますが、reboot後はちゃんと実行した日時が表示されています。@<fn>{historySave}

//footnote[historySave][ちなみにhistoryはターミナルを「exit」して閉じるときに履歴が書き込まれるため、前述の「exit」で抜けずに赤い×を押してウィンドウを閉じたり、ネットワークがぶつっと切れてしまったりするとその分は記録されずに消えてしまいます。]

以上で「サーバを立てる」という作業はおしまいです。

=== ターミナルはなんのためにある？

ターミナルでyumやviを叩いてサーバの設定を色々してきましたが、ここで「結局、ターミナルって何なの？」という振り返りをしておきましょう。

@<ttb>{ターミナルはサーバを操作するための画面}です。

皆さんがパソコン使うときはモニタに表示された画面を見ながらキーボードとマウスを使って「フォルダを開いて先週作ったWordファイルを探す」とか「Wordファイルを開いて今週の報告書を書く」というような操作をすると思います。フォルダを開くときは「ダブルクリック」をして、書いた内容を保存するときは「上書き保存する」ボタンを押しますよね。

サーバも同じです。サーバを使うときは「ターミナル」という画面を開いて操作します。ディレクトリ@<fn>{dir}を開いて移動するときはダブルクリックの代わりにcd@<fn>{cd}というコマンドを叩いて移動しますし、ディレクトリの中を見るときもダブルクリックでフォルダを開く代わりにlsコマンドを叩いて見ます。

//footnote[dir][Linuxではフォルダのことをディレクトリと呼びます。]
//footnote[cd][change directoryの略。]

皆さんがいま使っているWindowsやMacといった「パソコン」だったらマウスやキーボードを使ってアイコンやボタンを見ながら操作できますが、サーバは基本的にこの真っ黒な「ターミナル」で文字を打って操作します。パソコンのときはダブルクリックやボタンを押す、という形で伝えていた命令がすべてコマンドに置き換わっていると思ってください。

パソコンもないのにマウスやキーボードだけあっても意味が無いように、ターミナルもそれ単体では何もできません。操作対象であるサーバがあって初めて役に立つ道具なのです。

ちなみにターミナルは背景の色も文字の色も好きに変えられます。どうしても「黒い画面怖い！」という感覚が抜けない人は、ピンクとかオレンジとか好きな色にしてみましょう。@<fn>{color}

//footnote[color][Macのターミナルはそもそも黒じゃなくて白ですね。]

まとめるとターミナルとはサーバを操作するための画面で、操作するときにはコマンドという命令を使います。